{"version":3,"sources":["../src/thumbor.ts","../src/types.ts","../src/utils.ts"],"sourcesContent":["import crypto from 'crypto';\nimport {\n  FitInType,\n  HorizontalPosition,\n  ImageOperations,\n  ThumborOptions,\n  VerticalPosition,\n  WindowSizeAndPosition\n} from './types';\n\n/**\n * Create a Thumbor client for generating image URLs\n * @param options Configuration options for the Thumbor client\n */\nexport function createThumbor(options: ThumborOptions) {\n  const {\n    serverUrl,\n    securityKey,\n    requiresSecurityKey = !!securityKey,\n    cloaked = false\n  } = options;\n  let operations: ImageOperations = createEmptyOperations();\n\n  /**\n   * Create an empty operations object\n   */\n  function createEmptyOperations(): ImageOperations {\n    return {\n      imagePath: '',\n      filters: []\n    };\n  }\n\n  /**\n   * Reset the operations to default values\n   */\n  function resetOperations() {\n    operations = createEmptyOperations();\n  }\n\n  /**\n   * Set the image path\n   * @param path Path to the image\n   */\n  function setImagePath(path: string) {\n    operations.imagePath = path.startsWith('/') ? path.slice(1) : path;\n    return api;\n  }\n\n  /**\n   * Set the image URL\n   * @param url URL of the image\n   */\n  function setImageUrl(url: string) {\n    operations.imagePath = url;\n    return api;\n  }\n\n  /**\n   * Resize the image\n   * @param width Desired width\n   * @param height Desired height\n   */\n  function resize(width?: number, height?: number) {\n    operations.width = width;\n    operations.height = height;\n    operations.fitIn = undefined;\n    return api;\n  }\n\n  /**\n   * Enable smart cropping\n   * @param enable Whether to enable smart cropping\n   */\n  function smartCrop(enable = true) {\n    operations.smart = enable;\n    return api;\n  }\n\n  /**\n   * Enable trimming of the image\n   */\n  function trim() {\n    operations.trim = true;\n    return api;\n  }\n\n  /**\n   * Set fit-in parameters\n   * @param width Width to fit in\n   * @param height Height to fit in\n   * @param type Type of fitting\n   */\n  function fitIn(width: number, height: number, type = FitInType.DEFAULT) {\n    operations.width = width;\n    operations.height = height;\n    operations.fitIn = type;\n    return api;\n  }\n\n  /**\n   * Flip the image horizontally\n   */\n  function flipHorizontally() {\n    operations.flipHorizontally = true;\n    return api;\n  }\n\n  /**\n   * Flip the image vertically\n   */\n  function flipVertically() {\n    operations.flipVertically = true;\n    return api;\n  }\n\n  /**\n   * Set horizontal alignment\n   * @param align Horizontal alignment\n   */\n  function horizontalAlign(align: HorizontalPosition) {\n    operations.halign = align;\n    return api;\n  }\n\n  /**\n   * Set vertical alignment\n   * @param align Vertical alignment\n   */\n  function verticalAlign(align: VerticalPosition) {\n    operations.valign = align;\n    return api;\n  }\n\n  /**\n   * Add a filter\n   * @param filterCall Filter expression\n   */\n  function filter(filterCall: string) {\n    operations.filters = operations.filters || [];\n    operations.filters.push(filterCall);\n    return api;\n  }\n\n  /**\n   * Set crop values\n   * @param crop Crop dimensions\n   */\n  function crop(crop: WindowSizeAndPosition) {\n    operations.crop = crop;\n    return api;\n  }\n\n  /**\n   * Format the image to a specific type\n   * @param format Image format (webp, jpeg, png, etc)\n   */\n  function format(format: string) {\n    return filter(`format(${format})`);\n  }\n\n  /**\n   * Set the image quality\n   * @param quality Quality percentage (1-100)\n   */\n  function quality(quality: number) {\n    return filter(`quality(${quality})`);\n  }\n\n  /**\n   * Set the image brightness\n   * @param amount Brightness amount (-100 to 100)\n   */\n  function brightness(amount: number) {\n    return filter(`brightness(${amount})`);\n  }\n\n  /**\n   * Set the image contrast\n   * @param amount Contrast amount (-100 to 100)\n   */\n  function contrast(amount: number) {\n    return filter(`contrast(${amount})`);\n  }\n\n  /**\n   * Apply a grayscale filter\n   */\n  function grayscale() {\n    return filter('grayscale()');\n  }\n\n  /**\n   * Apply a blur to the image\n   * @param radius Blur radius\n   */\n  function blur(radius: number) {\n    return filter(`blur(${radius})`);\n  }\n\n  /**\n   * Convert URL parts based on operations\n   */\n  function getUrlParts(): string[] {\n    const parts: string[] = [];\n\n    if (operations.trim) {\n      parts.push('trim');\n    }\n\n    if (operations.crop) {\n      parts.push(\n        `${operations.crop.left}x${operations.crop.top}:${operations.crop.right}x${operations.crop.bottom}`\n      );\n    }\n\n    if (operations.fitIn) {\n      parts.push(operations.fitIn);\n    }\n\n    if (\n      operations.width !== undefined ||\n      operations.height !== undefined ||\n      operations.flipHorizontally ||\n      operations.flipVertically\n    ) {\n      let sizeString = '';\n\n      if (operations.flipHorizontally) {\n        sizeString += '-';\n      }\n\n      sizeString += operations.width ?? 0;\n      sizeString += 'x';\n\n      if (operations.flipVertically) {\n        sizeString += '-';\n      }\n\n      sizeString += operations.height ?? 0;\n\n      parts.push(sizeString);\n    }\n\n    if (operations.halign) {\n      parts.push(operations.halign);\n    }\n\n    if (operations.valign) {\n      parts.push(operations.valign);\n    }\n\n    if (operations.smart) {\n      parts.push('smart');\n    }\n\n    if (operations.filters && operations.filters.length > 0) {\n      parts.push(`filters:${operations.filters.join(':')}`);\n    }\n\n    return parts;\n  }\n\n  /**\n   * Build the operation path for the URL\n   */\n  function getOperationPath(): string {\n    const parts = getUrlParts();\n    return parts.length > 0 ? parts.join('/') : '';\n  }\n\n/**\n   * Build the final URL with all operations\n   */\nfunction buildUrl(): string {\n  const operationPath = getOperationPath();\n  const imagePath = operations.imagePath;\n  const dataToEncrypt = operationPath\n    ? `${operationPath}/${imagePath}`\n    : imagePath;\n\n  // Always use unsafe mode, otherwise check security key\n  let url = `${serverUrl}/unsafe/${dataToEncrypt}`;\n\n  if (securityKey && requiresSecurityKey) {\n    const digest = crypto\n      .createHmac('sha1', securityKey)\n      .update(dataToEncrypt)\n      .digest('base64')\n      .replace(/\\+/g, '-')\n      .replace(/\\//g, '_');\n\n    url = `${serverUrl}/${digest}/${dataToEncrypt}`;\n\n  }\n  if (cloaked) {\n    url = `${serverUrl}/${dataToEncrypt}`;\n  }\n  // Reset operations for next use\n  resetOperations();\n\n  return url;\n}\n\n  // Public API\n  const api = {\n    setImagePath,\n    setImageUrl,\n    resize,\n    smartCrop,\n    trim,\n    fitIn,\n    flipHorizontally,\n    flipVertically,\n    horizontalAlign,\n    verticalAlign,\n    filter,\n    crop,\n    format,\n    quality,\n    brightness,\n    contrast,\n    grayscale,\n    blur,\n    buildUrl\n  };\n\n  return api;\n}\n","/**\n * Options for configuring the Thumbor client\n */\nexport interface ThumborOptions {\n  /**\n   * URL of the Thumbor server\n   */\n  serverUrl: string;\n\n  /**\n   * Optional security key for accessing the Thumbor server\n   */\n  securityKey?: string;\n\n  /**\n   * Whether to require security key for URL generation\n   * @default true if securityKey is provided\n   */\n  requiresSecurityKey?: boolean;\n\n  /**\n   * Whether to always use unsafe mode (no security key)\n   * This overrides requiresSecurityKey if set to true\n   * @default false\n   */\n  unsafeMode?: boolean;\n\n  /**\n   * Whether to use cloaked URLs which will be rewritten by the server\n   * This is useful for hiding the original image URL/thumbor\n   * @default false\n   */\n  cloaked?: boolean;\n}\n\nexport interface WindowSizeAndPosition {\n  top: number;\n  bottom: number;\n  left: number;\n  right: number;\n}\n\nexport interface ImageOperations {\n  imagePath: string;\n  width?: number;\n  height?: number;\n  smart?: boolean;\n  trim?: boolean;\n  fitIn?: FitInType;\n  flipHorizontally?: boolean;\n  flipVertically?: boolean;\n  halign?: HorizontalPosition;\n  valign?: VerticalPosition;\n  crop?: WindowSizeAndPosition;\n  filters?: string[];\n}\n\n/**\n * Different types of fitting for an image\n */\nexport enum FitInType {\n  DEFAULT = 'fit-in',\n  FULL = 'full-fit-in',\n  ADAPTIVE = 'adaptative-fit-in',\n}\n\n/**\n * Vertical position options\n */\nexport enum VerticalPosition {\n  TOP = 'top',\n  MIDDLE = 'middle',\n  BOTTOM = 'bottom',\n}\n\n/**\n * Horizontal position options\n */\nexport enum HorizontalPosition {\n  LEFT = 'left',\n  CENTER = 'center',\n  RIGHT = 'right',\n}\n\n/**\n * Common image transformation options\n */\nexport interface ImageTransformOptions {\n  width?: number;\n  height?: number;\n  smartCrop?: boolean;\n  quality?: number;\n  format?: 'webp' | 'jpeg' | 'png' | 'avif';\n  blur?: number;\n  grayscale?: boolean;\n  trim?: boolean;\n  flipHorizontally?: boolean;\n  flipVertically?: boolean;\n}\n","import { createThumbor } from './thumbor';\nimport { ImageTransformOptions, ThumborOptions } from './types';\n\n/**\n * Cache the Thumbor client instance for reuse\n */\nlet thumborClientInstance: ReturnType<typeof createThumbor> | null = null;\n\n/**\n * Get or create a Thumbor client instance\n */\nexport function getThumbor(options?: Partial<ThumborOptions>) {\n  // Try to use environment variables by default in both Node.js and browser environments\n  const getEnv = (key: string) => {\n    if (typeof process !== 'undefined' && process.env) {\n      return process.env[key] || '';\n    }\n    return '';\n  };\n\n  const defaultOptions: ThumborOptions = {\n    serverUrl: getEnv('NEXT_PUBLIC_THUMBOR_SERVER_URL'),\n    securityKey: getEnv('THUMBOR_SECURITY_KEY'),\n    requiresSecurityKey: !!getEnv('THUMBOR_SECURITY_KEY'),\n  };\n\n  // Create a new client if it doesn't exist or if options are provided\n  if (!thumborClientInstance || options) {\n    thumborClientInstance = createThumbor({\n      ...defaultOptions,\n      ...options,\n    });\n  }\n\n  return thumborClientInstance;\n}\n\n/**\n * Generate an optimized image URL using Thumbor\n *\n * @param originalUrl Original image URL\n * @param options Transformation options\n * @returns Processed image URL\n */\nexport function getOptimizedImageUrl(originalUrl: string, options: ImageTransformOptions = {}): string {\n  if (!originalUrl) return '';\n\n  // Get the Thumbor client\n  const thumbor = getThumbor();\n\n  // Start building the image URL\n  let imageBuilder = thumbor.setImageUrl(originalUrl);\n\n  // Apply transformations based on options\n  if (options.width !== undefined || options.height !== undefined) {\n    imageBuilder = imageBuilder.resize(options.width, options.height);\n  }\n\n  if (options.smartCrop) {\n    imageBuilder = imageBuilder.smartCrop(true);\n  }\n\n  if (options.quality) {\n    imageBuilder = imageBuilder.quality(options.quality);\n  }\n\n  if (options.format) {\n    imageBuilder = imageBuilder.format(options.format);\n  }\n\n  if (options.blur) {\n    imageBuilder = imageBuilder.blur(options.blur);\n  }\n\n  if (options.grayscale) {\n    imageBuilder = imageBuilder.grayscale();\n  }\n\n  if (options.trim) {\n    imageBuilder = imageBuilder.trim();\n  }\n\n  if (options.flipHorizontally) {\n    imageBuilder = imageBuilder.flipHorizontally();\n  }\n\n  if (options.flipVertically) {\n    imageBuilder = imageBuilder.flipVertically();\n  }\n\n  // Build and return the final URL\n  return imageBuilder.buildUrl();\n}\n\n/**\n * Generate a responsive image URL for specific device sizes\n *\n * @param originalUrl Original image URL\n * @param options Base transformation options\n * @returns Object with URLs for different device sizes\n */\nexport function getResponsiveImageUrls(originalUrl: string, options: ImageTransformOptions = {}) {\n  return {\n    small: getOptimizedImageUrl(originalUrl, {\n      ...options,\n      width: options.width ? Math.floor(options.width / 3) : 320,\n    }),\n    medium: getOptimizedImageUrl(originalUrl, {\n      ...options,\n      width: options.width ? Math.floor(options.width / 1.5) : 768,\n    }),\n    large: getOptimizedImageUrl(originalUrl, options),\n  };\n}\n\n/**\n * Generate srcSet string for responsive images\n *\n * @param originalUrl Original image URL\n * @param options Base transformation options\n * @returns srcSet string for use in <img> tags\n */\nexport function getImageSrcSet(originalUrl: string, options: ImageTransformOptions = {}): string {\n  const widths = [320, 640, 960, 1280, 1920];\n\n  return widths\n    .map((width) => {\n      const url = getOptimizedImageUrl(originalUrl, {\n        ...options,\n        width,\n        height: options.height ? Math.floor((options.height * width) / (options.width || width)) : undefined,\n      });\n\n      return `${url} ${width}w`;\n    })\n    .join(', ');\n}\n"],"mappings":"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","names":["FitInType","VerticalPosition","HorizontalPosition","crop","format","quality"]}